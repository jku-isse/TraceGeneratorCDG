[{"id":1, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":2, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":3, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":4, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":5, "parametername":"GameTimer timer", "parametertype":"de.java_chess.javaChess.timer.GameTimer", "parameterclass":99, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":6, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":16, "methodname":"de.java_chess.javaChess.GameController.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":7, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":17, "methodname":"de.java_chess.javaChess.GameController.setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game notation.\r\n *\r\n * @param gameNotation\r\n * \t\tThe new game notation.\r\n */\r\npublic final void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":8, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":15, "methodname":"de.java_chess.javaChess.GameController.setEngine(de.java_chess.javaChess.engine.ChessEngine)", "isreturn":0, "sourcecode":"/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * \t\tThe new engine.\r\n */\r\nfinal void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}"},
 {"id":9, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":14, "methodname":"de.java_chess.javaChess.GameController.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nfinal void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":10, "parametername":"ChessBoardRenderer renderer", "parametertype":"de.java_chess.javaChess.renderer.ChessBoardRenderer", "parameterclass":82, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":19, "methodname":"de.java_chess.javaChess.GameController.setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)", "isreturn":0, "sourcecode":"/**\r\n * Set a new renderer.\r\n *\r\n * @param renderer\r\n * \t\tThe new renderer.\r\n */\r\nfinal void setRenderer(ChessBoardRenderer renderer) {\r\n    _renderer = renderer;\r\n}"},
 {"id":11, "parametername":"GameTimer timer", "parametertype":"de.java_chess.javaChess.timer.GameTimer", "parameterclass":99, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":18, "methodname":"de.java_chess.javaChess.GameController.setGameTimer(de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"/**\r\n * Set a new game timer.\r\n *\r\n * @param timer\r\n * \t\tThe new game timer.\r\n */\r\nfinal void setGameTimer(GameTimer timer) {\r\n    _gameTimer = timer;\r\n    timer.addActionListener(this);\r\n}"},
 {"id":12, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":23, "methodname":"de.java_chess.javaChess.GameController.userPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * The user moved a piece.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the user.\r\n */\r\npublic final void userPly(Ply ply) {\r\n    // Before any user ply can be applied, we have to stop\r\n    // the permanent brain, so the engine is free to process\r\n    // the user ply.\r\n    getEngine().stopPermanentBrain();\r\n    // plyInterpretation\r\n    ply = convertUserPly(ply);\r\n    // Check if the user has the right to move a piece\r\n    // and made a valid move.\r\n    if ((_moveRight) != (_computerIsWhite)) {\r\n        if ((((_gameState) != (GameState.CHECKMATE)) && ((_gameState) != (GameState.DRAW))) && ((_gameState) != (GameState.TIMEOUT))) {\r\n            if (getEngine().validateUserPly(ply)) {\r\n                doPly(ply);// Ok => move the piece.\r\n\r\n            } else {\r\n                // The user had to right to move or made an invalid move.\r\n                signalUserInputError(\"invalid move\");\r\n            }\r\n        } else {\r\n            signalUserInputError(\"game is already over\");\r\n        }\r\n    } else {\r\n        signalUserInputError(\"user is not about to move\");\r\n    }\r\n}"},
 {"id":13, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":14, "parametername":"de.java_chess.javaChess.ply.Ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":15, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":5, "methodname":"de.java_chess.javaChess.GameController.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to do.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    // If the game is over, stop here.\r\n    if ((_gameState) == (GameState.TIMEOUT)) {\r\n        return;\r\n    }\r\n    // Store the ply notation to set the check flags a bit later, since they are computed in the gameOver()\r\n    // call in the move right toggle.\r\n    PlyNotation plyNotation = new PlyNotationImpl(ply, getBoard().getPiece(ply.getSource()));\r\n    getGame().doPly(ply);\r\n    getBoard().doPly(ply);\r\n    getRenderer().doPly(ply);\r\n    // Now try to get some info on the current game state.\r\n    boolean gameOver = gameOver((!(_moveRight)));\r\n    // Set check info for this ply.\r\n    if ((_gameState) == (GameState.CHECKMATE)) {\r\n        plyNotation.setCheckMate(true);\r\n    } else {\r\n        if ((_gameState) == (GameState.CHECK)) {\r\n            plyNotation.setCheck(true);\r\n        }\r\n    }\r\n    // Add the ply to the notation.\r\n    getGameNotation().addPly(plyNotation);\r\n    if (gameOver) {\r\n        getGameTimer().stop();// The game has ended.\r\n\r\n        if ((_gameState) == (GameState.DRAW)) {\r\n            signalGameOver(\"Draw! Use File -> Reset to play again!\");\r\n        } else {\r\n            signalGameOver(((_moveRight) == (_computerIsWhite) ? \"Checkmate! I win! :-)\" : \"Checkmate! I lose... :-(\"));\r\n        }\r\n    } else {\r\n        toggleMoveRight();\r\n    }\r\n}"},
 {"id":16, "parametername":"JavaChessAction action", "parametertype":"de.java_chess.javaChess.action.JavaChessAction", "parameterclass":6, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":29, "methodname":"de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)", "isreturn":0, "sourcecode":"/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * \t\tThe action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}"},
 {"id":17, "parametername":"ChessEngineImpl engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":26, "methodname":"de.java_chess.javaChess.JavaChess.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "isreturn":0, "sourcecode":"public void engineStatusChanged(ChessEngineImpl engine) {\r\n    if ((this.jpStatus) != null) {\r\n        this.jpStatus.setActionText(engine.getStatusDisplayString());\r\n    }\r\n}"},
 {"id":18, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":9, "classname":"de.java_chess.javaChess.action.SaveGameAction", "methodid":49, "methodname":"de.java_chess.javaChess.action.SaveGameAction.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * \t\tThe game notation.\r\n */\r\npublic SaveGameAction(GameNotation gameNotation) {\r\n    super(\"Save game\");\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":19, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":9, "classname":"de.java_chess.javaChess.action.SaveGameAction", "methodid":50, "methodname":"de.java_chess.javaChess.action.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * \t\tThe name of the action.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":20, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":10, "classname":"de.java_chess.javaChess.action.SaveGameAsAction", "methodid":53, "methodname":"de.java_chess.javaChess.action.SaveGameAsAction.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\npublic SaveGameAsAction(GameNotation gameNotation) {\r\n    super(\"Save game as...\", gameNotation);\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":21, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":68, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}"},
 {"id":22, "parametername":"de.java_chess.javaChess.piece.Piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":68, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}"},
 {"id":23, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":71, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set, or null to empty the square.\r\n * @param position\r\n * \t\tThe position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}"},
 {"id":24, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":71, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set, or null to empty the square.\r\n * @param position\r\n * \t\tThe position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}"},
 {"id":25, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":62, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    Piece movedPiece = getPiece(ply.getSource());\r\n    // Check, if it was a castling\r\n    if (ply instanceof CastlingPly) {\r\n        int offset = (movedPiece.isWhite()) ? 0 : 56;\r\n        if (((CastlingPly) (ply)).isLeftCastling()) {\r\n            setPiece(movedPiece, new PositionImpl((2 + offset)));\r\n            // Move the rook to the right\r\n            doPly(new PlyImpl(new PositionImpl((0 + offset)), new PositionImpl((3 + offset)), false));\r\n        } else {\r\n            setPiece(movedPiece, new PositionImpl((6 + offset)));\r\n            // Move the rook to the left\r\n            doPly(new PlyImpl(new PositionImpl((7 + offset)), new PositionImpl((5 + offset)), false));\r\n        }\r\n    } else {\r\n        // If a pawn has just reached the last row\r\n        if (ply instanceof TransformationPly) {\r\n            // Set a piece of the new type on the destination square.\r\n            setPiece(new PieceImpl(((TransformationPly) (ply)).getTypeAfterTransformation(), movedPiece.getColor()), ply.getDestination());\r\n        } else {\r\n            // Copy the piece from source square to destination square.\r\n            setPiece(movedPiece, ply.getDestination());\r\n            // If its a en passant ply, remove the attacked pawn.\r\n            if (ply instanceof EnPassantPly) {\r\n                setPiece(null, ((EnPassantPly) (ply)).getAttackedPosition());\r\n            }\r\n        }\r\n    }\r\n    // Empty the source square.\r\n    setPiece(null, ply.getSource());\r\n}"},
 {"id":26, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":65, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}"},
 {"id":27, "parametername":"de.java_chess.javaChess.board.Board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":65, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}"},
 {"id":28, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":76, "methodname":"de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);"},
 {"id":29, "parametername":"de.java_chess.javaChess.piece.Piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":76, "methodname":"de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);"},
 {"id":30, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":78, "methodname":"de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set.\r\n * @param position\r\n * \t\tThe position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);"},
 {"id":31, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":78, "methodname":"de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set.\r\n * @param position\r\n * \t\tThe position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);"},
 {"id":32, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":73, "methodname":"de.java_chess.javaChess.board.Board.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * \t\tThe move to perform.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":33, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":75, "methodname":"de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);"},
 {"id":34, "parametername":"de.java_chess.javaChess.board.Board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":75, "methodname":"de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);"},
 {"id":35, "parametername":"DialogAbout adaptee", "parametertype":"de.java_chess.javaChess.dialogs.DialogAbout", "parameterclass":14, "classid":15, "classname":"de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter", "methodid":86, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.-init-(de.java_chess.javaChess.dialogs.DialogAbout)", "isreturn":0, "sourcecode":"DialogAbout_CloseButton_keyAdapter(DialogAbout adaptee) {\r\n    this.adaptee = adaptee;\r\n}"},
 {"id":36, "parametername":"SetupBoardDialog dialog", "parametertype":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "parameterclass":18, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":96, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)", "isreturn":0, "sourcecode":"public void setCallingDialog(SetupBoardDialog dialog) {\r\n    this.setupBoardDialog = dialog;\r\n}"},
 {"id":37, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":122, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(BitBoard board);"},
 {"id":38, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":121, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);"},
 {"id":39, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":118, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);"},
 {"id":40, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":124, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * \t\tA PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}"},
 {"id":41, "parametername":"PlyGenerator plyGenerator", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":124, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * \t\tA PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}"},
 {"id":42, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":132, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(BitBoard board) {\r\n    _board = board;\r\n}"},
 {"id":43, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":133, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":44, "parametername":"PlyGenerator plyGenerator", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":135, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)", "isreturn":0, "sourcecode":"/**\r\n * Set a new PlyGenerator instance.\r\n *\r\n * @param plyGenerator\r\n * \t\tThe new PlyGenerator instance.\r\n */\r\nprivate final void setPlyGenerator(PlyGenerator plyGenerator) {\r\n    _plyGenerator = plyGenerator;\r\n}"},
 {"id":45, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":131, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}"},
 {"id":46, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":126, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}"},
 {"id":47, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":148, "methodname":"de.java_chess.javaChess.engine.ChessEngine.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\nvoid setGame(Game game);"},
 {"id":48, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":147, "methodname":"de.java_chess.javaChess.engine.ChessEngine.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(Board board);"},
 {"id":49, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":152, "methodname":"de.java_chess.javaChess.engine.ChessEngine.validateUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\nboolean validateUserPly(Ply ply);"},
 {"id":50, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":153, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":51, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":153, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":52, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":153, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":53, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":188, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":54, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":186, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":55, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":189, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * \t\tThe new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}"},
 {"id":56, "parametername":"PermanentBrain permanentBrain", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "parameterclass":34, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":193, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)", "isreturn":0, "sourcecode":"/**\r\n * Set a new permanent brain.\r\n *\r\n * @param permanentBrain\r\n * \t\tThe new permanent brain.\r\n */\r\nprivate final void setPermanentBrain(PermanentBrain permanentBrain) {\r\n    _permanentBrain = permanentBrain;\r\n}"},
 {"id":57, "parametername":"OpeningBook book", "parametertype":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "parameterclass":31, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":192, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "isreturn":0, "sourcecode":"/**\r\n * Set a new opening book.\r\n *\r\n * @param book\r\n * \t\tThe new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}"},
 {"id":58, "parametername":"Ply lastPly", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":59, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":60, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":158, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}"},
 {"id":61, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":203, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}"},
 {"id":62, "parametername":"EnginePanel panel", "parametertype":"de.java_chess.javaChess.renderer2d.EnginePanel", "parameterclass":89, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":187, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)", "isreturn":0, "sourcecode":"/**\r\n * Sets the EnginePanel to be able to output in the panel and not only with\r\n * System.out.println(...)\r\n *\r\n * @param panel\r\n * \t\tThe EnginePanel to set\r\n */\r\npublic void setEnginePanel(EnginePanel panel) {\r\n    this._enginePanel = panel;\r\n}"},
 {"id":63, "parametername":"StatusPanel myPanel", "parametertype":"de.java_chess.javaChess.renderer2d.StatusPanel", "parameterclass":96, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":196, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)", "isreturn":0, "sourcecode":"public void setStatusPanel(StatusPanel myPanel) {\r\n    if ((this._statusPanel) != myPanel)\r\n        this._statusPanel = myPanel;\r\n\r\n}"},
 {"id":64, "parametername":"EngineStatusListener listener", "parametertype":"de.java_chess.javaChess.listener.EngineStatusListener", "parameterclass":53, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":156, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)", "isreturn":0, "sourcecode":"/**\r\n * Registers an object for notification.\r\n *\r\n * @param listener\r\n * \t\tThe object to be registered.\r\n */\r\npublic void addEngineStatusListener(EngineStatusListener listener) {\r\n    listeners.add(listener);\r\n}"},
 {"id":65, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":204, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}"},
 {"id":66, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":204, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}"},
 {"id":67, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":205, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param board\r\n * \t\tThe board to operate on.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}"},
 {"id":68, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":205, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param board\r\n * \t\tThe board to operate on.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}"},
 {"id":69, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":205, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param board\r\n * \t\tThe board to operate on.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}"},
 {"id":70, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":237, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":71, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":238, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * \t\tThe new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}"},
 {"id":72, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":229, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that lead to the given board.\r\n * @param board\r\n * \t\tThe board with the game position.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}"},
 {"id":73, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":236, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nfinal void setBoard(BitBoard board) {\r\n    _board = board;\r\n}"},
 {"id":74, "parametername":"BitBoardAnalyzer analyzer", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "parameterclass":20, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":235, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)", "isreturn":0, "sourcecode":"/**\r\n * Set the last ply.\r\n *\r\n * @param lastPly\r\n * \t\tThe last ply.\r\n */\r\n/* final void setLastPly( Ply lastPly) {\n// _lastPly = lastPly;\n}\n */\r\n/**\r\n * Set a analyzer for check tests.\r\n *\r\n * @param analyzer\r\n * \t\tThe new analyzer to set.\r\n */\r\npublic final void setAnalyzer(BitBoardAnalyzer analyzer) {\r\n    _analyzer = analyzer;\r\n}"},
 {"id":75, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":217, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to add.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}"},
 {"id":76, "parametername":"PlyHashtableEntry ply", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry", "parameterclass":27, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":243, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "isreturn":0, "sourcecode":"/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * \t\tThe new entry, that the hashtable might store.\r\n */\r\nvoid pushEntry(PlyHashtableEntry ply);"},
 {"id":77, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":241, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe board before the move.\r\n * @param white\r\n * \t\tFlag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);"},
 {"id":78, "parametername":"de.java_chess.javaChess.ply.Ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":241, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe board before the move.\r\n * @param white\r\n * \t\tFlag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);"},
 {"id":79, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":252, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * \t\tThe board before the ply.\r\n * @param ply\r\n * \t\tThe ply to store.\r\n * @param searchDepth\r\n * \t\tThe search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":80, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":252, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * \t\tThe board before the ply.\r\n * @param ply\r\n * \t\tThe ply to store.\r\n * @param searchDepth\r\n * \t\tThe search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":81, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":259, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board for this entry.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":82, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":260, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to set.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":83, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":257, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}"},
 {"id":84, "parametername":"PlyHashtableEntry ply", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry", "parameterclass":27, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":266, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "isreturn":0, "sourcecode":"/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * \t\tThe new entry, that the hashtable might store.\r\n */\r\npublic final void pushEntry(PlyHashtableEntry ply) {\r\n    // Compute and store the key for this ply.\r\n    Long hashKey = new Long(ply.hashKey());\r\n    // Check if this ply is not already in the hashtable\r\n    PlyHashtableEntry oldEntry = ((PlyHashtableEntry) (_hashtable.get(hashKey)));\r\n    if (oldEntry != null) {\r\n        // There is a entry with the same key\r\n        if ((oldEntry.getSearchDepth()) >= (ply.getSearchDepth())) {\r\n            return;// This entry shouldnt be replaced.\r\n\r\n        }\r\n    } else {\r\n        // Now we actually add a new entry to the table.\r\n        // Check, if the hashtable has not exceeded its maximum capacity\r\n        // and remove older entries, if necessary.\r\n        while ((getSize()) >= (getMaximumSize())) {\r\n            removeOldestEntry();\r\n        } \r\n    }\r\n    // Put the new ply into the hashtable\r\n    _hashtable.put(hashKey, ply);\r\n    // Append the new ply at the end of the list of plies.\r\n    // ATTENTION: this will only work, if theres only _one_\r\n    // ply for each key!\r\n    _orderedList.add(hashKey);\r\n}"},
 {"id":85, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":264, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":86, "parametername":"de.java_chess.javaChess.ply.Ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":264, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":87, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":30, "classname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl", "methodid":271, "methodname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\tFlag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}"},
 {"id":88, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":31, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "methodid":274, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBook.doUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Advance the game by one user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply from the user.\r\n */\r\nvoid doUserPly(Ply ply);"},
 {"id":89, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":277, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this class.\r\n *\r\n * @param notation\r\n * \t\tThe notation of the current game.\r\n */\r\npublic OpeningBookImpl(GameNotation notation) {\r\n    setNotation(notation);\r\n    // Create a new dynamic array for the openings.\r\n    _openings = new ArrayList();\r\n    // Reset the opening book.\r\n    reset();\r\n}"},
 {"id":90, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":279, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.doUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The user just did a ply.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n */\r\npublic final void doUserPly(Ply ply) {\r\n    // If we are already in a opening, check if the current user\r\n    // move doesnt lead us out of the opening line.\r\n    if ((_currentOpening) != (-1)) {\r\n        if (!(isInOpening(_currentOpening))) {\r\n            _currentOpening = -1;\r\n        }\r\n    }\r\n}"},
 {"id":91, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":285, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.setNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set the notation of the current game.\r\n *\r\n * @param notation\r\n * \t\tThe notation of the current game.\r\n */\r\nprivate final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}"},
 {"id":92, "parametername":"OpeningBook book", "parametertype":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "parameterclass":31, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":286, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param book\r\n * \t\tThe opening book, we are operating on.\r\n */\r\npublic LoadOpeningsAction(OpeningBook book) {\r\n    super(\"Load openings from PGN...\");\r\n    setOpeningBook(book);\r\n}"},
 {"id":93, "parametername":"OpeningBook book", "parametertype":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "parameterclass":31, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":291, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "isreturn":0, "sourcecode":"/**\r\n * Set the opening book, we are operating on.\r\n *\r\n * @param book\r\n * \t\tThe new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}"},
 {"id":94, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":292, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.-init-(de.java_chess.javaChess.engine.ChessEngine)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new PermanentBrain instance.\r\n *\r\n * @param engine\r\n * \t\tThe used chess engine.\r\n */\r\npublic PermanentBrain(ChessEngine engine) {\r\n    setEngine(engine);\r\n}"},
 {"id":95, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":298, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.setEngine(de.java_chess.javaChess.engine.ChessEngine)", "isreturn":0, "sourcecode":"/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * \t\tThe new chess engine.\r\n */\r\nprivate final void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}"},
 {"id":96, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":294, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"},
 {"id":97, "parametername":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPly", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPly", "parameterclass":35, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":294, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"},
 {"id":98, "parametername":"AnalyzedPly ply", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPly", "parameterclass":69, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":303, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * \t\tThe computed ply.\r\n * @param searchDepth\r\n * \t\tThe used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":99, "parametername":"AnalyzedPly ply", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPly", "parameterclass":69, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":306, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setPly(de.java_chess.javaChess.ply.AnalyzedPly)", "isreturn":0, "sourcecode":"/**\r\n * Set the computed ply.\r\n *\r\n * @param ply\r\n * \t\tThe computed ply.\r\n */\r\nprivate final void setPly(AnalyzedPly ply) {\r\n    _ply = ply;\r\n}"},
 {"id":100, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":38, "classname":"de.java_chess.javaChess.engine.test.AnalyzerTest2", "methodid":314, "methodname":"de.java_chess.javaChess.engine.test.AnalyzerTest2.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":101, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":39, "classname":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1", "methodid":321, "methodname":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":102, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":42, "classname":"de.java_chess.javaChess.engine.test.MinimaxTest1", "methodid":331, "methodname":"de.java_chess.javaChess.engine.test.MinimaxTest1.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":103, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":43, "classname":"de.java_chess.javaChess.engine.test.MinimaxTest2", "methodid":336, "methodname":"de.java_chess.javaChess.engine.test.MinimaxTest2.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":104, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":44, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1", "methodid":341, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":105, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":45, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2", "methodid":346, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":106, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":46, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3", "methodid":351, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":107, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":47, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4", "methodid":356, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":108, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":48, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5", "methodid":361, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":109, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":49, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6", "methodid":366, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":110, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":50, "classname":"de.java_chess.javaChess.game.Game", "methodid":370, "methodname":"de.java_chess.javaChess.game.Game.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Add a new ply to the game.\r\n *\r\n * @unknown The new ply.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":111, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":50, "classname":"de.java_chess.javaChess.game.Game", "methodid":373, "methodname":"de.java_chess.javaChess.game.Game.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * \t\tThe position to check.\r\n */\r\nboolean hasBeenMoved(Position position);"},
 {"id":112, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":388, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,long)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this game status.\r\n * @param bitmask\r\n * \t\tThe moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}"},
 {"id":113, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":389, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * \t\tThe first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}"},
 {"id":114, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":390, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "isreturn":0, "sourcecode":"/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * \t\tThe previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}"},
 {"id":115, "parametername":"GameImpl.GameStatus previousStatus", "parametertype":"de.java_chess.javaChess.game.GameImpl$GameStatus", "parameterclass":51, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":390, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "isreturn":0, "sourcecode":"/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * \t\tThe previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}"},
 {"id":116, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":396, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply, that lead to this game status.\r\n *\r\n * @param ply\r\n * \t\tThe ply, that lead to this game status.\r\n */\r\nfinal void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":117, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":394, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.setMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Mark a piece moved from its initial position.\r\n *\r\n * @param position\r\n * \t\tThe position of the moved piece.\r\n */\r\nprivate final void setMoved(Position position) {\r\n    _movedPieces |= 1L << (position.getSquareIndex());\r\n}"},
 {"id":118, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":393, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}"},
 {"id":119, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":380, "methodname":"de.java_chess.javaChess.game.GameImpl.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Do a new ply in this game.\r\n *\r\n * @param ply\r\n * \t\tThe next ply.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    // Add a new game status, that derives from the previous status.\r\n    _gameStatus.push(((getLastGameStatus()) == null ? new GameImpl.GameStatus(ply) : new GameImpl.GameStatus(ply, getLastGameStatus())));\r\n}"},
 {"id":120, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":384, "methodname":"de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * \t\tThe position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}"},
 {"id":121, "parametername":"ChessEngineImpl engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":53, "classname":"de.java_chess.javaChess.listener.EngineStatusListener", "methodid":397, "methodname":"de.java_chess.javaChess.listener.EngineStatusListener.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "isreturn":0, "sourcecode":"public void engineStatusChanged(ChessEngineImpl engine);"},
 {"id":122, "parametername":"NotationPanel panel", "parametertype":"de.java_chess.javaChess.renderer2d.NotationPanel", "parameterclass":92, "classid":54, "classname":"de.java_chess.javaChess.menu.EditMenu", "methodid":401, "methodname":"de.java_chess.javaChess.menu.EditMenu.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "isreturn":0, "sourcecode":"/**\r\n * Sets the NotationPanel to be able to perform some actions there\r\n *\r\n * @param panel\r\n * \t\tThe NotationPanel object\r\n */\r\npublic final void setNotationPanel(NotationPanel panel) {\r\n    this.notationPanel = panel;\r\n}"},
 {"id":123, "parametername":"PlyNotation plyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":402, "methodname":"de.java_chess.javaChess.notation.GameNotation.addPly(de.java_chess.javaChess.notation.PlyNotation)", "isreturn":0, "sourcecode":"/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * \t\tThe notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation);"},
 {"id":124, "parametername":"PlyNotation plyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":414, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.addPly(de.java_chess.javaChess.notation.PlyNotation)", "isreturn":0, "sourcecode":"/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * \t\tThe notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation) {\r\n    _plies.add(plyNotation);\r\n    int nPlies = _plies.size();// Get the number of plies.\r\n\r\n    if ((nPlies & 1) != 0) {\r\n        if (nPlies > 1) {\r\n            // Start a new line\r\n            _notation.append(\"\n\");\r\n        }\r\n        _notation.append(((\"\" + ((nPlies >> 1) + 1)) + \". \"));\r\n    } else {\r\n        _notation.append(\" \");\r\n    }\r\n    _notation.append(plyNotation.toString());\r\n    // If theres a panel, display the current notation.\r\n    if (null != (getNotationPanel())) {\r\n        getNotationPanel().setText(toString());\r\n    }\r\n}"},
 {"id":125, "parametername":"NotationPanel notationPanel", "parametertype":"de.java_chess.javaChess.renderer2d.NotationPanel", "parameterclass":92, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":423, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "isreturn":0, "sourcecode":"/**\r\n * Set the panel for the notation output.\r\n *\r\n * @param notationPanel\r\n * \t\tThe panel for the output.\r\n */\r\npublic final void setNotationPanel(NotationPanel notationPanel) {\r\n    _notationPanel = notationPanel;\r\n}"},
 {"id":126, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":57, "classname":"de.java_chess.javaChess.notation.PlyNotation", "methodid":436, "methodname":"de.java_chess.javaChess.notation.PlyNotation.setPiece(de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * \t\tThe moved ply.\r\n */\r\nvoid setPiece(Piece piece);"},
 {"id":127, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":57, "classname":"de.java_chess.javaChess.notation.PlyNotation", "methodid":437, "methodname":"de.java_chess.javaChess.notation.PlyNotation.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this notation.\r\n */\r\nvoid setPly(Ply ply);"},
 {"id":128, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":439, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n * @param piece\r\n * \t\tThe moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}"},
 {"id":129, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":439, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n * @param piece\r\n * \t\tThe moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}"},
 {"id":130, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":449, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.setPiece(de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * \t\tThe moved ply.\r\n */\r\npublic final void setPiece(Piece piece) {\r\n    _piece = piece;\r\n}"},
 {"id":131, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":450, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this notation.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":132, "parametername":"PGNPlyFragment plyFragment", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":453, "methodname":"de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * \t\tThe info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}"},
 {"id":133, "parametername":"de.java_chess.javaChess.notation.PlyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":453, "methodname":"de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * \t\tThe info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}"},
 {"id":134, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":454, "methodname":"de.java_chess.javaChess.pgn.GameLoader.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply, when it is completely loaded.\r\n *\r\n * param ply The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n    // The other color is about to move now.\r\n    _whiteMoves = !(_whiteMoves);\r\n}"},
 {"id":135, "parametername":"PGNParser parser", "parametertype":"de.java_chess.javaChess.pgn.PGNParser", "parameterclass":64, "classid":60, "classname":"de.java_chess.javaChess.pgn.PGNFile", "methodid":459, "methodname":"de.java_chess.javaChess.pgn.PGNFile.setPGNParser(de.java_chess.javaChess.pgn.PGNParser)", "isreturn":0, "sourcecode":"/**\r\n * Set the current parser.\r\n *\r\n * @param parser\r\n * \t\tThe new PGN parser.\r\n */\r\nprivate final void setPGNParser(PGNParser parser) {\r\n    _parser = parser;\r\n}"},
 {"id":136, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":63, "classname":"de.java_chess.javaChess.pgn.PGNOutputStream", "methodid":492, "methodname":"de.java_chess.javaChess.pgn.PGNOutputStream.write(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Write the notation of a game.\r\n *\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\npublic final void write(GameNotation gameNotation) throws IOException {\r\n    // Check, if there is some header available.\r\n    String header = gameNotation.getPGNheader();\r\n    if (!(\"\".equals(header))) {\r\n        header += \"\n\";\r\n        write(header.getBytes());\r\n    }\r\n    write(gameNotation.toString().getBytes());\r\n}"},
 {"id":137, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":511, "methodname":"de.java_chess.javaChess.pgn.PGNParser.setNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set a new buffer for the game notation.\r\n *\r\n * @param notation\r\n * \t\tThe new notation buffer.\r\n */\r\npublic final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}"},
 {"id":138, "parametername":"GameLoader loader", "parametertype":"de.java_chess.javaChess.pgn.GameLoader", "parameterclass":59, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":510, "methodname":"de.java_chess.javaChess.pgn.PGNParser.setGameLoader(de.java_chess.javaChess.pgn.GameLoader)", "isreturn":0, "sourcecode":"/**\r\n * Set a new game loader.\r\n *\r\n * @param loader\r\n * \t\tThe new game loader.\r\n */\r\nprivate final void setGameLoader(GameLoader loader) {\r\n    _gameLoader = loader;\r\n}"},
 {"id":139, "parametername":"GameNotation notationBuffer", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":506, "methodname":"de.java_chess.javaChess.pgn.PGNParser.pgnGame(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"public final void pgnGame(GameNotation notationBuffer) throws RecognitionException, TokenStreamException {\r\n    setNotation(notationBuffer);\r\n    setGameLoader(new GameLoader());\r\n    whiteSpaces();\r\n    tagPairSection();\r\n    moveTextSection();\r\n}"},
 {"id":140, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":530, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the name of the origin square.\r\n *\r\n * @param position\r\n * \t\tThe position of the origin square.\r\n */\r\npublic final void setOrigin(Position position) {\r\n    // Store the position.\r\n    _origin = position;\r\n}"},
 {"id":141, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":69, "classname":"de.java_chess.javaChess.ply.AnalyzedPly", "methodid":552, "methodname":"de.java_chess.javaChess.ply.AnalyzedPly.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * \t\tThe new ply.\r\n */\r\nvoid setPly(Ply ply);"},
 {"id":142, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":554, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}"},
 {"id":143, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":558, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * \t\tThe new ply.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":144, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":72, "classname":"de.java_chess.javaChess.ply.CastlingPlyImpl", "methodid":562, "methodname":"de.java_chess.javaChess.ply.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}"},
 {"id":145, "parametername":"Position attackedPosition", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":73, "classname":"de.java_chess.javaChess.ply.EnPassantPly", "methodid":567, "methodname":"de.java_chess.javaChess.ply.EnPassantPly.setAttackedPosition(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * \t\tThe position of the attacked pawn.\r\n */\r\nvoid setAttackedPosition(Position attackedPosition);"},
 {"id":146, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":568, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square of the attacking pawn.\r\n * @param destination\r\n * \t\tThe destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}"},
 {"id":147, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":568, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square of the attacking pawn.\r\n * @param destination\r\n * \t\tThe destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}"},
 {"id":148, "parametername":"Position attackedPosition", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":568, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square of the attacking pawn.\r\n * @param destination\r\n * \t\tThe destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}"},
 {"id":149, "parametername":"Position attackedPosition", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":570, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.setAttackedPosition(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic final void setAttackedPosition(Position attackedPosition) {\r\n    _attackedPosition = attackedPosition;\r\n}"},
 {"id":150, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":75, "classname":"de.java_chess.javaChess.ply.Ply", "methodid":576, "methodname":"de.java_chess.javaChess.ply.Ply.setSource(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the source of the ply.\r\n *\r\n * @param source\r\n * \t\tThe new source square for this ply.\r\n */\r\nvoid setSource(Position source);"},
 {"id":151, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":75, "classname":"de.java_chess.javaChess.ply.Ply", "methodid":575, "methodname":"de.java_chess.javaChess.ply.Ply.setDestination(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * \t\tThe new destination square of this ply.\r\n */\r\nvoid setDestination(Position destination);"},
 {"id":152, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":75, "classname":"de.java_chess.javaChess.ply.Ply", "methodid":571, "methodname":"de.java_chess.javaChess.ply.Ply.equals(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * \t\tThe other ply.\r\n * @return true, if the 2 plies are equal. False otherwise.\r\n */\r\nboolean equals(Ply ply);"},
 {"id":153, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":577, "methodname":"de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param capture\r\n * \t\tFlag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}"},
 {"id":154, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":577, "methodname":"de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param capture\r\n * \t\tFlag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}"},
 {"id":155, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":584, "methodname":"de.java_chess.javaChess.ply.PlyImpl.setSource(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the source of the ply.\r\n *\r\n * @param The\r\n * \t\tnew source of the piece.\r\n */\r\npublic final void setSource(Position source) {\r\n    _source = source;\r\n}"},
 {"id":156, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":583, "methodname":"de.java_chess.javaChess.ply.PlyImpl.setDestination(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * \t\tThe new destination of the piece.\r\n */\r\npublic final void setDestination(Position destination) {\r\n    _destination = destination;\r\n}"},
 {"id":157, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":578, "methodname":"de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * \t\tThe other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}"},
 {"id":158, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":588, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param pieceType\r\n * \t\tThe piece type after the transformation.\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}"},
 {"id":159, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":588, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param pieceType\r\n * \t\tThe piece type after the transformation.\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}"},
 {"id":160, "parametername":"Position pos", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":80, "classname":"de.java_chess.javaChess.position.Position", "methodid":592, "methodname":"de.java_chess.javaChess.position.Position.equals(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * \t\tposition.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\nboolean equals(Position pos);"},
 {"id":161, "parametername":"Position pos", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":600, "methodname":"de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * \t\tposition.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}"},
 {"id":162, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":82, "classname":"de.java_chess.javaChess.renderer.ChessBoardRenderer", "methodid":610, "methodname":"de.java_chess.javaChess.renderer.ChessBoardRenderer.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(Board board);"},
 {"id":163, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":82, "classname":"de.java_chess.javaChess.renderer.ChessBoardRenderer", "methodid":606, "methodname":"de.java_chess.javaChess.renderer.ChessBoardRenderer.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Render a piece move.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":164, "parametername":"PiecesLayer piecesLayer", "parametertype":"de.java_chess.javaChess.renderer2d.PiecesLayer", "parameterclass":94, "classid":83, "classname":"de.java_chess.javaChess.renderer2d.AnimationLayer", "methodid":611, "methodname":"de.java_chess.javaChess.renderer2d.AnimationLayer.-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new AnimationLayer instance.\r\n *\r\n * @param piecesLayer\r\n * \t\tThe layer with the pieces.\r\n */\r\nAnimationLayer(PiecesLayer piecesLayer) {\r\n    setPiecesLayer(piecesLayer);\r\n}"},
 {"id":165, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":83, "classname":"de.java_chess.javaChess.renderer2d.AnimationLayer", "methodid":612, "methodname":"de.java_chess.javaChess.renderer2d.AnimationLayer.animatePly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Animate the move of a piece.\r\n */\r\nvoid animatePly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":166, "parametername":"PiecesLayer piecesLayer", "parametertype":"de.java_chess.javaChess.renderer2d.PiecesLayer", "parameterclass":94, "classid":83, "classname":"de.java_chess.javaChess.renderer2d.AnimationLayer", "methodid":615, "methodname":"de.java_chess.javaChess.renderer2d.AnimationLayer.setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"/**\r\n * Set a new pieces layer.\r\n *\r\n * @param piecesLayer\r\n * \t\tThe new pieces layer.\r\n */\r\nvoid setPiecesLayer(PiecesLayer piecesLayer) {\r\n    _piecesLayer = piecesLayer;\r\n}"},
 {"id":167, "parametername":"GameController controller", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":624, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * \t\tThe game controller.\r\n * @param board\r\n * \t\tThe current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}"},
 {"id":168, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":624, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * \t\tThe game controller.\r\n * @param board\r\n * \t\tThe current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}"},
 {"id":169, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":626, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Render a ply (the move of a piece).\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    _piecesLayer.doPly(ply);\r\n    repaint();\r\n}"},
 {"id":170, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":634, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":171, "parametername":"GameController controller", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":636, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}"},
 {"id":172, "parametername":"PiecesLayer pl", "parametertype":"de.java_chess.javaChess.renderer2d.PiecesLayer", "parameterclass":94, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":636, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}"},
 {"id":173, "parametername":"GameController controller", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":641, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.setController(de.java_chess.javaChess.GameController)", "isreturn":0, "sourcecode":"/**\r\n * Set a new game controller.\r\n *\r\n * @param The\r\n * \t\tnew game controller.\r\n */\r\nprivate final void setController(GameController controller) {\r\n    _controller = controller;\r\n}"},
 {"id":174, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":680, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Standardconstructor\r\n */\r\npublic NotationPanel(GameNotation gameNotation) {\r\n    super();\r\n    // Store the game notation in this instance.\r\n    setGameNotation(gameNotation);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":175, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":687, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set a new notation object.\r\n *\r\n * @param gameNotation\r\n * \t\tThe new game notation.\r\n */\r\npublic void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":176, "parametername":"ChessSet set", "parametertype":"de.java_chess.javaChess.renderer2d.ChessSet", "parameterclass":86, "classid":93, "classname":"de.java_chess.javaChess.renderer2d.PieceRenderer", "methodid":690, "methodname":"de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * \t\tThe color of the piece.\r\n * @param piece\r\n * \t\tThe type of the piece.\r\n * @param set\r\n * \t\tThe set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}"},
 {"id":177, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":691, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.-init-(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"PiecesLayer(Board board) {\r\n    super(new GridLayout(8, 8));\r\n    _set = new ChessSet(this);\r\n    _animationLayer = new AnimationLayer(this);\r\n    _board = board;\r\n    int _boardSize = 8 * (ChessBoardRenderer2D.getSquareSize());\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    setOpaque(false);\r\n    repaintBoard();\r\n}"},
 {"id":178, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":693, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Render a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    if (_animatedMoves) {\r\n        getAnimationLayer().animatePly(ply);\r\n        getAnimationLayer().start();\r\n        repaint();\r\n    } else {\r\n        // Check, if it was a castling\r\n        if (ply instanceof CastlingPly) {\r\n            int source = ply.getSource().getSquareIndex();\r\n            if (((CastlingPly) (ply)).isLeftCastling()) {\r\n                _square[(source - 2)].getPieceFrom(_square[source]);\r\n                _square[(source - 1)].getPieceFrom(_square[(source - 4)]);// Move the rook to the right\r\n\r\n            } else {\r\n                _square[(source + 2)].getPieceFrom(_square[source]);\r\n                _square[(source + 1)].getPieceFrom(_square[(source + 3)]);// Move the rook to the left\r\n\r\n            }\r\n        } else {\r\n            // If a pawn has just reached the last row\r\n            if (ply instanceof TransformationPly) {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // Now change the rendering to the new piece type.\r\n                _square[ply.getDestination().getSquareIndex()].setIcon(new ImageIcon(new PieceRenderer(((ply.getDestination().getSquareIndex()) < 8 ? Piece.BLACK : Piece.WHITE), ((TransformationPly) (ply)).getTypeAfterTransformation(), _set, this)));\r\n            } else {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // If its a en passant ply, remove the attacked pawn.\r\n                if (ply instanceof EnPassantPly) {\r\n                    _square[((EnPassantPly) (ply)).getAttackedPosition().getSquareIndex()].setIcon(null);\r\n                }\r\n            }\r\n        }\r\n        repaint();\r\n    }\r\n}"},
 {"id":179, "parametername":"PositionRenderer positionRenderer", "parametertype":"de.java_chess.javaChess.renderer2d.PositionRenderer", "parameterclass":95, "classid":95, "classname":"de.java_chess.javaChess.renderer2d.PositionRenderer", "methodid":699, "methodname":"de.java_chess.javaChess.renderer2d.PositionRenderer.getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Move a piece from another position to this one.\r\n *\r\n * positionRenderer The position renderer for the source.\r\n */\r\nvoid getPieceFrom(PositionRenderer positionRenderer) {\r\n    setIcon(positionRenderer.getIcon());\r\n    positionRenderer.setIcon(null);\r\n}"}]